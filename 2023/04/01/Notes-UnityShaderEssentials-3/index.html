<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Unity Shader入门精要》笔记（三） | 楸涵の小窝</title><meta name="author" content="楸涵"><meta name="copyright" content="楸涵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="基础动画、屏幕后处理、使用深度和法线纹理">
<meta property="og:type" content="article">
<meta property="og:title" content="《Unity Shader入门精要》笔记（三）">
<meta property="og:url" content="https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/index.html">
<meta property="og:site_name" content="楸涵の小窝">
<meta property="og:description" content="基础动画、屏幕后处理、使用深度和法线纹理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg">
<meta property="article:published_time" content="2023-03-31T16:00:02.000Z">
<meta property="article:modified_time" content="2024-07-27T15:13:59.656Z">
<meta property="article:author" content="楸涵">
<meta property="article:tag" content="TA">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="《UnityShader入门精要》">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Unity Shader入门精要》笔记（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-27 23:13:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="css/resources.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="css/progress_bar.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="楸涵の小窝" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-facebook-messenger"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-meteor"></i><span> AboutMe</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/100789898_p0_master1200.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="楸涵の小窝"><span class="site-name">楸涵の小窝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-facebook-messenger"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-meteor"></i><span> AboutMe</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Unity Shader入门精要》笔记（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-31T16:00:02.000Z" title="发表于 2023-04-01 00:00:02">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-27T15:13:59.656Z" title="更新于 2024-07-27 23:13:59">2024-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Unity Shader入门精要》笔记（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础动画">基础动画</h2>
<h3 id="Unity内置的时间变量">Unity内置的时间变量</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_Time</td>
<td style="text-align:center">float4</td>
<td style="text-align:center">t是场景加载开始持续的时间，变量类型表示为(t/20, t, 2t, 3t)</td>
</tr>
<tr>
<td style="text-align:center">_SinTime</td>
<td style="text-align:center">float4</td>
<td style="text-align:center">t是时间的正弦值，分别表示为(t/8, t/4, t/2, t)</td>
</tr>
<tr>
<td style="text-align:center">_CosTime</td>
<td style="text-align:center">float4</td>
<td style="text-align:center">t是时间的余弦值，分别表示为(t/8, t/4, t/2, t)</td>
</tr>
<tr>
<td style="text-align:center">unity_DeltaTime</td>
<td style="text-align:center">float4</td>
<td style="text-align:center">dt是时间增量，分别表示为(dt, 1/dt, smoothDt, 1/smoothDt)</td>
</tr>
</tbody>
</table>
<h3 id="纹理动画">纹理动画</h3>
<ul>
<li>关键帧图像存放一组动画序列帧的一张贴图</li>
<li>纹理动画的核心在于fragment shader中动态调整读取贴图的位置，计算不同时刻子图像的纹理坐标范围，实现关键帧动画</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/ImageSequence&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex(&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _HorizontalAmount(&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _VerticalAmount(&quot;Vertical Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _Speed(&quot;Play Speed&quot;, Range(<span class="number">1</span>,<span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            Zwrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed);</span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time/_HorizontalAmount);<span class="comment">//通过商获取行索引</span></span><br><span class="line">                <span class="type">float</span> colum = time - row * _HorizontalAmount;<span class="comment">//通过余数获取列索引</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//half2 uv = float2(i.uv.x/_HorizontalAmount, i.uv.y/_VerticalAmount);//获取每个帧的读取的初始位置（知道是那个位置，类似于百分比的东西，然后再用行和列加到真正的位置</span></span><br><span class="line">                <span class="comment">//uv.x += colum/_HorizontalAmount;//相加获取正确的x位置</span></span><br><span class="line">                <span class="comment">//uv.y -= row/_VerticalAmount;//相加获取正确的y位置</span></span><br><span class="line">                </span><br><span class="line">                half2 uv = i.uv + half2(colum,-row);<span class="comment">//另一个理解方式：先获取正确的位置</span></span><br><span class="line">                uv.x /= _HorizontalAmount;<span class="comment">//再除到0-1区间内</span></span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以上row要以 - 的形式遍历，因为逐帧贴图是从上开始到下的</span></span><br><span class="line"></span><br><span class="line">                fixed4 color = tex2D(_MainTex, uv);</span><br><span class="line">                color.rgb *= _Color;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本质上就是将原本的0-1的贴图读取范围映射到对应当前帧的范围内</p>
</blockquote>
<h3 id="顶点动画">顶点动画</h3>
<ul>
<li>
<p>需要关闭批处理，因为顶点动画需要在模型空间下进行顶点位置偏移的计算，批处理会使得所有相关的模型合并，导致这些模型各自的模型空间丢失。</p>
</li>
<li>
<p>核心在于vertex中对模型顶点进行计算偏移</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">    <span class="comment">//因为给到的water的模型在其坐标空间内x方向是上下方向，所以使用sin对模型空间内的x进行变换</span></span><br><span class="line">    <span class="comment">//实际上的模型为 A sin(at + b)，根据不同物体的不同对象空间来决定</span></span><br><span class="line">    <span class="comment">//在此案例下x为波动的方向（竖轴），z为横轴，*v.vertex.z是因为通过不同的z的位置来控制不同的波动，否则会没有起伏的海浪的效果，只会整体移动</span></span><br><span class="line">    <span class="comment">//所以b=z,而_InvWaveLength则是告诉z应该被分为几段</span></span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    o.uv += float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>阴影投射Pass：vert中直接把偏移值加到顶点位置变量中，再使用TRANSFER_SHADOW_CASTER_NORMALOFFSET来让unity做剩下的事；frag中直接使用TRANSFER_SHADOW_CASTER_FRAGMENT来让unity自动完成阴影投射</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Pass to render object as a shadow caster</span></span><br><span class="line">   Tags</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">    &#125;<span class="comment">//将光照模式设置为阴影投射</span></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#pragma vertex vert</span></span><br><span class="line">    <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#pragma multi_compile_shadowcaster//声明阴影投射的变体</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _Magnitude;</span><br><span class="line">    <span class="type">float</span> _Frequency;</span><br><span class="line">    <span class="type">float</span> _InvWaveLength;</span><br><span class="line"></span><br><span class="line">    struct v2f</span><br><span class="line">    &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     v2f vert(appdata_base v) <span class="comment">//阴影投射需要输入为v.normal和v.vertex的变量，所以可以直接使用appdata_base</span></span><br><span class="line">     &#123;</span><br><span class="line">         v2f o;</span><br><span class="line">         float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">         v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line">         TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">         <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fixed4 frag(v2f i) : SV_Target</span><br><span class="line">      &#123;</span><br><span class="line">         SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/Water&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Magnitude(&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Frequency(&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _InvWaveLength(&quot;Distortion Inversal Wave Length&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Speed(&quot;Speed&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需要禁用批处理batching，因为本案例需要在模型空间下对顶点进行偏移，而批处理会合并所有相关的模型导致这些模型各自的模型空间丢失</span></span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">                <span class="comment">//因为给到的water的模型在其坐标空间内x方向是上下方向，所以使用sin对模型空间内的x进行变换</span></span><br><span class="line">                <span class="comment">//实际上的模型为 A sin(at + b)，根据不同物体的不同对象空间来决定</span></span><br><span class="line">                <span class="comment">//在此案例下x为波动的方向（竖轴），z为横轴，*v.vertex.z是因为通过不同的z的位置来控制不同的波动，否则会没有起伏的海浪的效果，只会整体移动</span></span><br><span class="line">                <span class="comment">//所以b=z,而_InvWaveLength则是告诉z应该被分为几段</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv += float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 color = tex2D(_MainTex, i.uv) * _Color;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Pass to render object as a shadow caster</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">            &#125;<span class="comment">//将光照模式设置为阴影投射</span></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster//声明阴影投射的变体</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_base v) <span class="comment">//阴影投射需要输入为v.normal和v.vertex的变量，所以可以直接使用appdata_base</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = _Magnitude * <span class="built_in">sin</span>(_Time.y * _Frequency * <span class="built_in">abs</span>(v.vertex.x) + _InvWaveLength * v.vertex.z);</span><br><span class="line">                v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Billboarding">Billboarding</h3>
<p>实现效果：让物体始终正面朝向摄像机</p>
<p>应用场所：面片草</p>
<p>计算原理：</p>
<p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/UnityShaderEssentials11.png" alt="UnityShaderEssentials11"></p>
<ol>
<li>确定物体本地空间的轴朝向
<ol>
<li>确定物体指向摄像机的方向为物体本地空间的法线（Z轴）朝向，得到确定的normal</li>
<li>通过利用物体本身向上的轴和法线，叉乘计算出物体本地坐标系向右方向的轴朝向，得到确定的right（其中需要判断UpDir会不会和Normal平行，如果平行会导致cross无效）</li>
<li>通过确定的normal和right叉乘计算出确定的up</li>
</ol>
</li>
<li>根据原始位置相对于锚点的偏移量以及三个正交基计算出新的顶点位置（x轴在right轴上投影，y轴在up轴上投影，z轴在normal轴上投影）</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/BillBoeard&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _VerticalBillboarding(&quot;Vertial Constraints&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;DisableBatching&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _VerticalBillboarding;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//选择以模型空间的原点为锚点</span></span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));<span class="comment">//注意不能用内置的UnityWorldToObjectDir，因为这个计算的只是方向，会做normalize，导致无法得到正确的position</span></span><br><span class="line">                <span class="comment">//获取假定的目标法线</span></span><br><span class="line">                float3 normalDir = viewer - center;</span><br><span class="line">                <span class="comment">//如果_VerticalBillboarding=0,则说明向上的方向被固定，法线的y分量为0</span></span><br><span class="line">                <span class="comment">//如果_VerticalBillboarding=1,则说明法线方向被固定，以视野看向物体中心的反方向为法线方向</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                normalDir = <span class="built_in">normalize</span>(normalDir); <span class="comment">//标准化为单位向量</span></span><br><span class="line">                <span class="comment">//获取大致的向上向量upDir，为了避免upDir和法线平行（导致cross无效），需要进行判断</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//如果法线指向正上方，则upDir就指向前方；否则upDir指向正上方</span></span><br><span class="line">                float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">                <span class="comment">//通过准确的rightDir和normalDir来叉乘获取准确的upDir，由此获得正交基向量</span></span><br><span class="line">                upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line">                <span class="comment">//通过原本坐标系中的偏移值来获取顶点的新坐标位置</span></span><br><span class="line">                float3 <span class="keyword">offset</span> = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * <span class="keyword">offset</span>.x + upDir * <span class="keyword">offset</span>.y + normalDir * <span class="keyword">offset</span>.z;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">                color.rgb *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>顶点动画如果在模型空间下进行计算需要禁用批处理，但因此会带来一定的性能下降，增加Draw Call，因此我们应该尽量避免在模型空间下用一些绝对位置和方向进行计算</li>
<li>顶点动画需要我们自己提供shadowcaster</li>
</ul>
<h2 id="屏幕后处理">屏幕后处理</h2>
<h3 id="屏幕后处理基本脚本系统">屏幕后处理基本脚本系统</h3>
<h4 id="OnRenderImage函数——得到渲染后的屏幕图像">OnRenderImage函数——得到渲染后的屏幕图像</h4>
<ul>
<li>默认在所有的不透明和透明pass被执行完毕后调用</li>
<li>可以在OnRenderImage函数前添加ImageEffectOpaque属性来实现在不透明pass执行完毕、透明pass执行之前调用</li>
</ul>
<h4 id="Graphics-Blit——完成对渲染纹理的处理">Graphics.Blit——完成对渲染纹理的处理</h4>
<p>三种声明：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">public static <span class="type">void</span> Blit(Texture src, RenderTexture dest);</span><br><span class="line">public static <span class="type">void</span> Blit(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>);</span><br><span class="line">public static <span class="type">void</span> Blit(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>src表示源纹理</li>
<li>dest表示渲染目标纹理，如果为null则结果会直接输出到屏幕上</li>
<li>mat表示用于渲染的材质</li>
<li>pass默认为-1，表示会依次调用所有的pass，否则会调用特定索引的pass</li>
</ul>
<h4 id="基类——检测兼容性">基类——检测兼容性</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">[RequireComponent(typeof(Camera))]</span><br><span class="line">public class PostEffectsBase : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //这个Base类用于处理子类所共有的check和construct material过程</span><br><span class="line">    </span><br><span class="line">    //在调用start时调用</span><br><span class="line">    protected void CheckResources()</span><br><span class="line">    &#123;</span><br><span class="line">        bool isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        if (isSupported == false)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected bool CheckSupport()//在CheckResource中被调用来查看当前平台是否支持</span><br><span class="line">    &#123;</span><br><span class="line">        if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogWarning(&quot;This Platform does not support image effects of render textures.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void NotSupported()//在不被当前平台支持时调用</span><br><span class="line">    &#123;</span><br><span class="line">        enabled = false;//禁用这个组件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Material CheckShaderAndCreateMaterial(Shader shader, Material material)//每个屏幕后处理效果通常需要指定一个shader来创建一个用于处理RT的材质，因此在基类提供这样的方法</span><br><span class="line">    //其中参数shader制定了该特效需使用的shader，第二个参数则是用于后期处理的材质</span><br><span class="line">    &#123;</span><br><span class="line">        if (shader == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)//检查shader的可用性，1.isSupported检查shader在当前GPU上是否被支持 2.material检查material是否为空 3.material.shader == shader检查当前材质的shader是否是传入的shader</span><br><span class="line">            return material;</span><br><span class="line"></span><br><span class="line">        if (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            material = new Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            if (material)</span><br><span class="line">                return material;</span><br><span class="line">            else</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基础后处理效果">基础后处理效果</h3>
<h4 id="调整屏幕的HSL">调整屏幕的HSL</h4>
<p>后处理C#脚本：继承自PostEffectBase类的实际效果类模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BrightnessSaturationAndContrast : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    //声明该效果需要的shader，并由此创建材质</span><br><span class="line">    public Shader briSatConShader;</span><br><span class="line">    public Material briSatConMaterial;</span><br><span class="line">    public Material material//注意看，这是一个属性</span><br><span class="line">    &#123;</span><br><span class="line">        get//get函数调用基类的CheckShaderAndCreateMaterial函数来获得对应的材质</span><br><span class="line">        //get是一个属性或索引器的一部分，返回属性的值或索引器的元素，作用是封装访问字段，提供更好的数据安全性和灵活性</span><br><span class="line">        &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader,briSatConMaterial);</span><br><span class="line">            return briSatConMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //提供调整亮度。饱和度和对比度的参数，并用Range属性提供变化区间</span><br><span class="line">    [Range(0.0f, 3.0f)] public float brightness = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)] public float saturation = 1.0f;</span><br><span class="line">    [Range(0.0f, 3.0f)] public float contrast = 1.0f;</span><br><span class="line">    </span><br><span class="line">    //定义OnRenderImage来进行真正的特效处理</span><br><span class="line">    private void OnRenderImage(RenderTexture src, RenderTexture dest)//屏幕后处理的基础在于得到渲染后的屏幕图像（抓取屏幕），Unity为我们提供了这样一个方便的接口——OnRenderImage函数</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_Brightness&quot;, brightness);</span><br><span class="line">            material.SetFloat(&quot;_Saturation&quot;,saturation);</span><br><span class="line">            material.SetFloat(&quot;_Contrast&quot;,contrast);</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src, dest, material);//在OnRenderImage函数中通常利用Graphics.Blit函数来完成对Render Texture的处理，src纹理将会传递给shader中名为_MainTex的纹理属性</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后处理shader：（重点在于fragment shader的处理）</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Brightness(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Properties可以省略，对于屏幕特效来说，他们使用的材质都是临时创建的</span></span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v) <span class="comment">//使用unity内置的appdata_img结构体作为顶点着色器的输入，它只包含了图像处理时必须的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityWorldToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord; <span class="comment">//uv无需再进行变换</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv); <span class="comment">//首先得到对原屏幕图像的采样结果renderTex</span></span><br><span class="line"></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness; <span class="comment">//通过Brightness来调整亮度（只需要把原本颜色乘上亮度系数_Brightness即可）</span></span><br><span class="line"></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b; <span class="comment">//计算该像素对应的亮度值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance); <span class="comment">//由亮度值创建一个饱和度为0的颜色值</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation); <span class="comment">//进行插值，得到期望饱和度</span></span><br><span class="line"></span><br><span class="line">                fixed3 abgColor = fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(abgColor, finalColor, _Contrast);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于RGB值计算像素亮度信息：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>u</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mn>0.2125</mn><mo>∗</mo><mi>r</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>0.7154</mn><mo>∗</mo><mi>g</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>0.0721</mn><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Luminance = 0.2125 *r \ + \ 0.7154*g \ + \ 0.0721 * b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lu</span><span class="mord mathnormal">minan</span><span class="mord mathnormal">ce</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.2125</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.7154</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0721</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<h4 id="高斯模糊">高斯模糊</h4>
<ul>
<li>原理：利用高斯核进行卷积运算</li>
</ul>
<p>C#代码：（注意其中对Render  Texture的内存处理）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            int rtW = src.width / downSample;//降低对原图的采样率，以减少开销；downSample越大性能越好，但是可能会导致图像的像素化</span><br><span class="line">            int rtH = src.height / downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;//设置纹理的滤波器模式为双线性滤波器</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src, buffer0);//把src的render texture写入buffer0中</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)//通过for循环控制高斯模糊的迭代次数</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);//更改用于模糊的像素量</span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);//为buffer1分配一个临时RT</span><br><span class="line"></span><br><span class="line">                //先处理第一个pass(pass0)--竖直方向的pass</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material,0);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);//</span><br><span class="line">                /*如果是使用等号赋值，会造成内存泄露，所以在使用=前需要释放buffer0的内存；但是如果是用Graphics.Blit(buffer0,buffer1,...)的话:</span><br><span class="line">                 ①当Graphics.Blit()接受两个参数时，它会将第一个参数（源纹理）复制到第二个参数（目标纹理），并且会自动释放目标纹理原来占用的内存空间。</span><br><span class="line">                 ②当Graphics.Blit()接受三个参数时，它会将第一个参数（源纹理）经过第三个参数（材质）的处理后复制到第二个参数（目标纹理），并且也会自动释放目标纹理原来占用的内存空间*/</span><br><span class="line">                buffer0 = buffer1;//再将buffer1的结果赋给buffer0,此时buffer1和buffer2指向同一个Render Texture</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);//所以需要为buffer1新指定一个Render Texture</span><br><span class="line">                </span><br><span class="line">                //处理第二个pass(pass1)--水平方向的pass</span><br><span class="line">                Graphics.Blit(buffer0, buffer1,material,1);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;//buffer0和buffer1之后共同指向同一个内存，所以不需要release buffer1</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Shader代码：</p>
<p>其中==使用了<strong>CGINCLUDE</strong>来组织代码==，并且在两个pass中分别计算竖直方向和水平方向的卷积</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/GuassianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//出错的地方：</span></span><br><span class="line">    <span class="comment">// 1.水平方向和竖直方向处理uv坐标时，float2的两个参数位置写错：写水平方向时直接复制了代码改了y-&gt;x，但是没有调换0.0和_MainTex_TexelSize.y * 1.0的位置</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="comment">//使用CGINCLUDE来组织代码，这些代码不需要包含在任何的Pass语义块中，在使用的时候我们只需要在Pass中直接指定需要使用的顶点着色器和片元着色器函数即可（类似于C++中的头文件）</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;<span class="comment">//因为要使用相邻像素的坐标</span></span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;<span class="comment">//使用5x5大小的高斯核对原图像进行高斯模糊处理，而一个5x5的高斯核可以拆分成两个大小为5的一维高斯核，因此我们只需要计算5个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//处理竖直方向</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理水平方向</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通用的fragment shader</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line"></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//应用卷积核</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fixed4(sum ,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;<span class="comment">//给pass命名，方便在其他地方调用该pass</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bloom效果">Bloom效果</h4>
<ul>
<li>实现原理
<ul>
<li>根据一个阈值提取像素中较亮的区域，将他们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散，再将其和原图像进行混合</li>
<li>使用多个pass进行处理
<ul>
<li>Pass0：提取高亮部分</li>
<li>Pass1，2：对亮度进行高斯模糊</li>
<li>Pass3：Bloom混合效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>C#代码整体与高斯模糊相似，唯一区别在于进入高斯模糊处理前使用Pass1提取了亮度大于阈值的部分（后续Blit处理的pass依次往后推）</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            </span><br><span class="line"><span class="deletion">-           Graphics.Blit(src, buffer0);</span></span><br><span class="line"><span class="addition">+           Graphics.Blit(src,buffer0,material,0);//第一个pass--&gt;处理提取亮度的过程</span></span><br><span class="line"></span><br><span class="line">            for (int i = 1;i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"><span class="addition">+           material.SetTexture(&quot;_Bloom&quot;,buffer0);</span></span><br><span class="line"><span class="deletion">-           Graphics.Blit(buffer0, dest); </span></span><br><span class="line"><span class="addition">+           raphics.Blit(src,dest,material,3); //将高斯模糊处理后的亮度图应用到原图上</span></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Shader代码：</p>
<p>==使用<strong>UsePass</strong>来复用之前高斯模糊的Pass==<strong>(Pass的名称要使用全大写)</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/GuassianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//出错的地方：</span></span><br><span class="line">    <span class="comment">// 1.水平方向和竖直方向处理uv坐标时，float2的两个参数位置写错：写水平方向时直接复制了代码改了y-&gt;x，但是没有调换0.0和_MainTex_TexelSize.y * 1.0的位置</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="comment">//使用CGINCLUDE来组织代码，这些代码不需要包含在任何的Pass语义块中，在使用的时候我们只需要在Pass中直接指定需要使用的顶点着色器和片元着色器函数即可（类似于C++中的头文件）</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;<span class="comment">//因为要使用相邻像素的坐标</span></span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;<span class="comment">//使用5x5大小的高斯核对原图像进行高斯模糊处理，而一个5x5的高斯核可以拆分成两个大小为5的一维高斯核，因此我们只需要计算5个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//处理竖直方向</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理水平方向</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通用的fragment shader</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line"></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//应用卷积核</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fixed4(sum ,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;<span class="comment">//给pass命名，方便在其他地方调用该pass</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于颜色亮度的边缘检测">基于颜色亮度的边缘检测</h4>
<p>C#代码中只是简单地对shader中一些数值进行调整：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using Unity.VisualScripting;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class EdgeDetection : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader edgeDetectShader;</span><br><span class="line">    private Material edgeDetectMaterial = null;</span><br><span class="line">    public Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            return edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 1.0f)] public float edgeOnly = 0.0f;</span><br><span class="line">    public Color edgeColor = Color.black;</span><br><span class="line">    public Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_OnlyEdge&quot;,edgeOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;,edgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src,dest,material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>shader描边关键在于用卷积核计算该像素周围的亮度差作为梯度（模拟二阶导），并基于梯度进行插值计算</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/EdgeDetection&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _OnlyEdge(&quot;Only Edge&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _edgeColor(&quot;Edge Color&quot;, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _backgroundColor(&quot;Background Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            <span class="type">float</span> _OnlyEdge;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">            struct v2f </span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找到目标像素点及其四周的九个像素点</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed luminance(fixed4 color)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">            &#125;</span><br><span class="line">            half Sobel(v2f i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                     <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;<span class="comment">//水平方向上的卷积核</span></span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;<span class="comment">//竖直方向上的卷积核</span></span><br><span class="line">                <span class="comment">//通过卷积核来计算梯度值</span></span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">0</span>;it &lt; <span class="number">9</span>;it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex,i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                half edge = <span class="built_in">abs</span>(edgeX) + <span class="built_in">abs</span>(edgeY);<span class="comment">//本来梯度应该是X和Y的平方根，但出于性能考虑，会用绝对值操作来代替开根</span></span><br><span class="line">                <span class="comment">//half edge = 1 - abs(edgeX) - abs(edgeY);//我不知道为什么要用一个OneMinus进行一次反向映射</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">                fixed4 withEdgeColor = lerp( tex2D(_MainTex, i.uv[<span class="number">4</span>]), _EdgeColor,edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp( _BackgroundColor, _EdgeColor, edge);</span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor,onlyEdgeColor,_OnlyEdge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用深度与法线纹理">使用深度与法线纹理</h2>
<h3 id="获取深度与法线纹理">获取深度与法线纹理</h3>
<h4 id="Unity中的深度和法线纹理">Unity中的深度和法线纹理</h4>
<p>深度纹理里的深度范围是[0,1]，且因为这些深度来源于NDC，所以通常是非线性分布的</p>
<p>Unity对深度纹理的获取方法：</p>
<ul>
<li>延迟渲染：直接访问GBuffer</li>
<li>无法直接获取深度缓存时：深度和法线纹理通过一个单独的Pass渲染获得。Unity会使用Shader Replacement着色器替换技术选择那些渲染类型（RenderType）为Opaque的物体，判断他们使用的渲染队列是否小于等于2500（内置的Background、Geometry、AlphaTest均在内），如果满足条件，就把他们渲染到深度和法线纹理中。因此，<strong>想要让物体能出现在深度和法线纹理中，就必须在Shader中设置正确的RenderType（&lt;=2500)</strong></li>
<li>可以选择让摄像机生成一张深度纹理或深度+法线纹理
<ul>
<li>生成一张深度纹理：Unity会直接获取深度缓存，或是使用着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的Pass（“LightMode” = “ShadowCaster”）来得到深度纹理。如果shader中不包含这样一个Pass，那这个物体就不会出现在深度纹理中（也不会投射阴影）</li>
<li>生成深度+法线纹理：Unity会创建一张和屏幕分辨率相同、精度为32（8*4）位的纹理，其中观察空间下的法线信息会被编码进纹理的R、G通道中，深度信息会被编码进B、A通道中（在获取法线纹理时，如果是延迟渲染，直接读取GBuffer即可；如果是前向渲染，unity会使用一个单独的Pass把场景再渲染一遍）</li>
</ul>
</li>
</ul>
<h4 id="如何获取">如何获取</h4>
<p>设置摄像机的depthTextureMode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;//获取深度+法线纹理</span><br><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;//获取深度纹理</span><br></pre></td></tr></table></figure>
<blockquote>
<p>摄像机的depthTextureMode默认为DepthTextureMode.Depth</p>
</blockquote>
<p>shader中采样深度纹理</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sampler = tex2D(_CameraDepthNormalsTexture, i.uv);<span class="comment">//绝大多数情况直接使用tex2D函数即可</span></span><br><span class="line"><span class="type">float</span> d = SMAPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<span class="comment">//Unity提供的用于处理平台造成的差异的统一的宏</span></span><br></pre></td></tr></table></figure>
<p>当通过纹理采样获得深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。</p>
<p>不过Unity提供了LinearEyeDepth和Linear01Depth两个辅助函数：</p>
<ul>
<li>LinearEyeDepth负责把深度纹理的采样结果转换到视角空间下的深度值</li>
<li>Linear01Depth会返回一个范围在[0,1]的线性深度值</li>
</ul>
<p>如果我们需要获得深度+法线纹理，Unity提供了DecodeDepthNormal来为我们获得的采样结果进行解码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">void</span> DecodeDepthNormal(float4 enc, <span class="keyword">out</span> <span class="type">float</span> depth, <span class="keyword">out</span> float3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.zw);</span><br><span class="line">    normal = DecodeViewNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得的深度值是[0,1]的线性深度值</li>
<li>得到的法线是视角空间下的法线方向</li>
</ul>
<h3 id="基于深度和法线的边缘检测">基于深度和法线的边缘检测</h3>
<p>C#中添加了控制采样距离的参数，和控制对深度和法线进行边缘检测时的灵敏度参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using Unity.VisualScripting;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class EdgeDetectionWithDepthAndNormal : PostEffectsBase</span><br><span class="line">&#123;</span><br><span class="line">    public Shader EdgeDetectionShader;</span><br><span class="line">    private Material EdgeDetectionMaterial = null;</span><br><span class="line"></span><br><span class="line">    private Material material</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            EdgeDetectionMaterial = CheckShaderAndCreateMaterial(EdgeDetectionShader, EdgeDetectionMaterial);</span><br><span class="line">            return EdgeDetectionMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Range(0.0f, 1.0f)] public float EdgeOnly = 0.0f;</span><br><span class="line">    public Color EdgeColor = Color.black;</span><br><span class="line">    public Color BackgroundColor = Color.white;</span><br><span class="line">    public float sampleDistance = 1.0f;</span><br><span class="line">    public float sensitivityDepth = 1.0f;</span><br><span class="line">    public float sensitivityNormal = 1.0f;</span><br><span class="line"></span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode = DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [ImageEffectOpaque]//标明该属性实现在渲染半透明前就调用此函数进行描边</span><br><span class="line">    private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_EdgeOnly&quot;, EdgeOnly);</span><br><span class="line">            material.SetColor(&quot;_EdgeColor&quot;,EdgeColor);</span><br><span class="line">            material.SetColor(&quot;_BackgroundColor&quot;,BackgroundColor);</span><br><span class="line">            material.SetFloat(&quot;_SampleDistance&quot;,sampleDistance);</span><br><span class="line">            material.SetVector(&quot;_Sensitivity&quot;,new Vector4(sensitivityNormal,sensitivityDepth,0,0));</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src,dest,material);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中在OnRenderImage前添加了ImageEffectOpaque属性，实现在渲染半透明前就调用此函数（不给半透明物体描边）</p>
</blockquote>
<p>shader中则是使用了Roberts算子，其本质是计算左上角和右下角的差值，乘以右上角和左下角的差值，以此作为评估边缘的依据</p>
<p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230612165636754.png" alt=""></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/EdgeDetectionWithDepthAndNormal&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Base (RGB)&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _EdgeColor(&quot;Edge Color&quot;,Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _BackgroundColor(&quot;Background Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _SampleDistance(&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity(&quot;Sensitivity(ND00)&quot;,Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _EdgeOnly(&quot;Edge Only&quot;, Float) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        vector _Sensitivity;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f vert(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize * half2(<span class="number">1</span>, <span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize * half2(<span class="number">-1</span>, <span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize * half2(<span class="number">1</span>, <span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize * half2(<span class="number">-1</span>, <span class="number">1</span>) * _SampleDistance;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half CheckSame(half4 center, half4 <span class="keyword">sample</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用Roberts算子进行边缘检测</span></span><br><span class="line"></span><br><span class="line">            half2 centerNormal = center.xy;</span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">            half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line"></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">            half2 diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="type">int</span> isSameDepth = <span class="built_in">abs</span>(diffDepth.x + diffDepth.y) &lt; <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (isSameDepth * isSameNormal) ? <span class="number">1.0</span> : <span class="number">0.0</span>; <span class="comment">//如果法线和深度都满足差距极小，则不加描边；否则进行描边处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            edge *= CheckSame(sample1, sample2);</span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line"></span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always ZWrite Off Cull Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://himoqiuhan.github.io">楸涵</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/">https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://himoqiuhan.github.io" target="_blank">楸涵の小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TA/">TA</a><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a><a class="post-meta__tags" href="/tags/%E3%80%8AUnityShader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E3%80%8B/">《UnityShader入门精要》</a></div><div class="post_share"><div class="social-share" data-image="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/01/Notes-UnityShaderEssentials-2/" title="《Unity Shader入门精要》笔记（二）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Unity Shader入门精要》笔记（二）</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/01/Notes-UnityShaderEssentials-4/" title="《Unity Shader入门精要》笔记（四）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Unity Shader入门精要》笔记（四）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/01/Notes-UnityShaderEssentials-1/" title="《Unity Shader入门精要》笔记（一）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">《Unity Shader入门精要》笔记（一）</div></div></a></div><div><a href="/2023/04/01/Notes-UnityShaderEssentials-2/" title="《Unity Shader入门精要》笔记（二）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">《Unity Shader入门精要》笔记（二）</div></div></a></div><div><a href="/2023/04/01/Notes-UnityShaderEssentials-4/" title="《Unity Shader入门精要》笔记（四）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/41TN3CwhyZL._SY346_.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">《Unity Shader入门精要》笔记（四）</div></div></a></div><div><a href="/2023/10/28/Notes-CatlikeCoding-CustomRenderPipline/" title="【Unity】自定义渲染管线学习笔记（Updating）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20231028195012.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-28</div><div class="title">【Unity】自定义渲染管线学习笔记（Updating）</div></div></a></div><div><a href="/2023/06/14/Notes-TA100-Ex100/" title="技术美术百人计划学习笔记（先行版-基础渲染光照介绍）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-14</div><div class="title">技术美术百人计划学习笔记（先行版-基础渲染光照介绍）</div></div></a></div><div><a href="/2023/06/13/Notes-TA100-T1400/" title="技术美术百人计划学习笔记（图形1.1-1.4）"><img class="cover" src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-13</div><div class="title">技术美术百人计划学习笔记（图形1.1-1.4）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楸涵</div><div class="author-info__description">嘿！一起突破次元壁吗！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="/about/"><i class="fas fa-meteor"></i><span>About Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/himoqiuhan" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/qiu-han-71-64/posts" target="_blank" title="Zhihu"><i class="fab fa-zhihu" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/374860285" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #24292e;"></i></a><a class="social-icon" href="https://steamcommunity.com/profiles/76561198866659933" target="_blank" title="Steam"><i class="fab fa-steam" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来和我聊天！</p> <p>QQ：1419091648</p> <p>微信：Himo_qiuhan</p></div></div><div class="card-widget card_portfolio"><div class="item-headline"><i></i><span>作品集</span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB"><span class="toc-number">1.</span> <span class="toc-text">基础动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E5%86%85%E7%BD%AE%E7%9A%84%E6%97%B6%E9%97%B4%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">Unity内置的时间变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">1.2.</span> <span class="toc-text">纹理动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">1.3.</span> <span class="toc-text">顶点动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Billboarding"><span class="toc-number">1.4.</span> <span class="toc-text">Billboarding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">屏幕后处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.</span> <span class="toc-text">屏幕后处理基本脚本系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnRenderImage%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%BE%97%E5%88%B0%E6%B8%B2%E6%9F%93%E5%90%8E%E7%9A%84%E5%B1%8F%E5%B9%95%E5%9B%BE%E5%83%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">OnRenderImage函数——得到渲染后的屏幕图像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Graphics-Blit%E2%80%94%E2%80%94%E5%AE%8C%E6%88%90%E5%AF%B9%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">Graphics.Blit——完成对渲染纹理的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">基类——检测兼容性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C"><span class="toc-number">2.2.</span> <span class="toc-text">基础后处理效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84HSL"><span class="toc-number">2.2.1.</span> <span class="toc-text">调整屏幕的HSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-number">2.2.2.</span> <span class="toc-text">高斯模糊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bloom%E6%95%88%E6%9E%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">Bloom效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%9C%E8%89%B2%E4%BA%AE%E5%BA%A6%E7%9A%84%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">基于颜色亮度的边缘检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">使用深度与法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">获取深度与法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">Unity中的深度和法线纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">如何获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%9A%84%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">3.2.</span> <span class="toc-text">基于深度和法线的边缘检测</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/Projects-Game-Unity-WitchsNight/" title="【Unity】颜色组合塔防游戏《女巫缤纷夜》"><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20240801012107.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Unity】颜色组合塔防游戏《女巫缤纷夜》"/></a><div class="content"><a class="title" href="/2024/07/30/Projects-Game-Unity-WitchsNight/" title="【Unity】颜色组合塔防游戏《女巫缤纷夜》">【Unity】颜色组合塔防游戏《女巫缤纷夜》</a><time datetime="2024-07-30T07:37:03.000Z" title="发表于 2024-07-30 15:37:03">2024-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/28/Notes-TA100-A4510/" title="技术美术百人计划学习笔记（美术4.5 特效规范及拆分实现）"><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术美术百人计划学习笔记（美术4.5 特效规范及拆分实现）"/></a><div class="content"><a class="title" href="/2024/07/28/Notes-TA100-A4510/" title="技术美术百人计划学习笔记（美术4.5 特效规范及拆分实现）">技术美术百人计划学习笔记（美术4.5 特效规范及拆分实现）</a><time datetime="2024-07-28T09:20:57.000Z" title="发表于 2024-07-28 17:20:57">2024-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/13/Anima-SoundEuphonium/" title="《響け！ユーフォニアム》杂谈"><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoundEuphonium-cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《響け！ユーフォニアム》杂谈"/></a><div class="content"><a class="title" href="/2024/02/13/Anima-SoundEuphonium/" title="《響け！ユーフォニアム》杂谈">《響け！ユーフォニアム》杂谈</a><time datetime="2024-02-13T06:14:39.000Z" title="发表于 2024-02-13 14:14:39">2024-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/Projects-GenshinLikeRenderingInURP2-Avatar/" title="【Unity】仿原神渲染2.0技术文档-角色渲染篇"><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/c29cb1345f98a9f92545947d81d692c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Unity】仿原神渲染2.0技术文档-角色渲染篇"/></a><div class="content"><a class="title" href="/2023/12/07/Projects-GenshinLikeRenderingInURP2-Avatar/" title="【Unity】仿原神渲染2.0技术文档-角色渲染篇">【Unity】仿原神渲染2.0技术文档-角色渲染篇</a><time datetime="2023-12-07T13:17:37.000Z" title="发表于 2023-12-07 21:17:37">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/Projects-GenshinLikeRenderingInURP2-PostProcess/" title="【Unity】仿原神渲染2.0技术文档-后处理篇"><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/c29cb1345f98a9f92545947d81d692c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Unity】仿原神渲染2.0技术文档-后处理篇"/></a><div class="content"><a class="title" href="/2023/12/07/Projects-GenshinLikeRenderingInURP2-PostProcess/" title="【Unity】仿原神渲染2.0技术文档-后处理篇">【Unity】仿原神渲染2.0技术文档-后处理篇</a><time datetime="2023-12-07T13:17:30.000Z" title="发表于 2023-12-07 21:17:30">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 楸涵</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到楸涵的小窝！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-68npiieuq-himoqiuhan.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>